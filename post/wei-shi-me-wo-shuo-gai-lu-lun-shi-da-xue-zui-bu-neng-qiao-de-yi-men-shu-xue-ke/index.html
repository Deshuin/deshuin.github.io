<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>为什么我说概率论是大学最不能翘的一门数学课 | Deshuin&#39;s Blog</title>
<link rel="shortcut icon" href="https://deshuin.github.io/favicon.ico?v=1701263753167">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://deshuin.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="为什么我说概率论是大学最不能翘的一门数学课 | Deshuin&#39;s Blog - Atom Feed" href="https://deshuin.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="这些天在构思概率论的期中论文，想了许久，都找不到一个很好的切入点，于是心血来潮，又重读了一遍吴军博士的《数学之美》，启迪颇丰，愈发感觉到概率论对于信息通信等学科的重要性，甚至将其称之为信息与通信工程学生在大学最不能翘的一门数学课都不为过，接..." />
    <meta name="keywords" content="数学" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://deshuin.github.io">
  <img class="avatar" src="https://deshuin.github.io/images/avatar.png?v=1701263753167" alt="">
  </a>
  <h1 class="site-title">
    Deshuin&#39;s Blog
  </h1>
  <p class="site-description">
    人类的尊严始于思想
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://deshuin.github.io/post/yun-ying-ri-zhi" class="menu">
          运营日志
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://deshuin.github.io/post/you-lian" class="menu">
          友联
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              为什么我说概率论是大学最不能翘的一门数学课
            </h2>
            <div class="post-info">
              <span>
                2023-11-06
              </span>
              <span>
                35 min read
              </span>
              
                <a href="https://deshuin.github.io/tag/DLzsL5shU/" class="post-tag">
                  # 数学
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>这些天在构思概率论的期中论文，想了许久，都找不到一个很好的切入点，于是心血来潮，又重读了一遍吴军博士的《数学之美》，启迪颇丰，愈发感觉到概率论对于信息通信等学科的重要性，甚至将其称之为信息与通信工程学生在大学最不能翘的一门数学课都不为过，接下来我希望通过我的论述来证明这一观点：为什么我说概率论是大学最不能翘的一门数学课</p>
<p>首先，我需要声明，本文中的大多数思想观点都受吴军博士启发，并非笔者原创，而其中涉及较多有关信息论，通信原理，贝叶斯网络，极大似然法，机器学习，隐含马尔可夫模型，EM算法等知识，对于尚未接触过概率论的读者而言，阅读起来可能有一点点困难，但笔者也希望以此文致敬吴军博士，尽量用深入浅出的文字和推理来帮助读者去理解我所要论述的观点，而笔者也会极大限度的减少公式的引入，因为霍金老先生说过：你的文章每多出一个公式，就会吓跑一半的读者，本文预计阅读时间40分钟（同时，需强调，笔者今年大二，现就读于北京某高校信息通信专业，才疏学浅，专业知识所学不多，所以我相信知乎上很多大V在这些方面会有更深的理解，希望其中有错误的地方，诸位能热心指正）</p>
<p>好了，如果你正在看笔者写的这篇文章，我建议你现在闭目养神静坐十秒钟，然后，咱们可以开始上车了</p>
<p>在开场前，我们先来玩一个小游戏，这是一个很经典的破冰游戏，现在假设你在一个教室里，同时周围有30名学生，游戏的规则是这样的：一开始，大家都是鸡蛋，你们需要和周围同类型的物种进行石头剪子布来升级，鸡蛋找鸡蛋划石头剪子布，胜利者就变成了小鸡。接着小鸡找小鸡划，胜利者就变成了凤凰，然后，凤凰和凤凰划，胜利者就变成了人，变成人的同学就是最后的赢家，同时，每次石头剪子布输的那一方都会降一级，比如从凤凰降级到小鸡，小鸡降级到鸡蛋，游戏限时十分钟，所以，现在问你在这个游戏中如何取胜（此处认真思考二十秒）</p>
<p>对于大多数玩家而言，是不会仔细思考这个游戏背后的数学模型的，但其实只要我们稍微想一想就会找到游戏取胜的秘诀，现在，我们假设每个人进行石头剪子布取胜的概率都是0.5，而由鸡蛋到人一共要连续赢三次，那么这个过程的概率就是（0.5）^ 3=1/8，看到这里有读者可能会问，既然每个人取胜的概率都是均等的，那么就并没有什么秘诀可言了，但我们不要忽略这个游戏是有时间限制的，于是就会自然而然的思考取胜的秘诀是否会和进行石头剪子布的频次有关呢</p>
<p>如果一个人在这十分钟内只进行一轮石头剪子布（我们现在定义由鸡蛋到人的三次石头剪子布为一轮，如果提前输掉则视作此轮结束）那么这个人变成人的概率为1/8，而如果它进行两轮，那么我们先不管他是在第一轮还是第二轮中变成了人，只要最后变成人了就OK，所以我们只用讨论它两轮都输的概率，就是（1-1/8）<sup>2，而变成人的概率为1-（1-1/8）</sup>2=15/64&gt;1/8，依次类推，可知道如果进行n轮，则他变成人的概率为1-（1-1/8）^n,当n趋于无穷时，这个概率将趋于 1，所以这个游戏取胜的秘诀就是不停的和周围的人进行石头剪子布，频次越高，也就越有机会变成人，而事实是人们在进行这个游戏时的本能反应也是如此，就是在不停的和周围人玩石头剪子布，赢了OK，输了继续，所以说人类在潜意识里已经看出了这个游戏背后的数学内涵</p>
<p>当然如果想对上述游戏进行一次完整而严谨的建模也将是一个十分复杂的过程，笔者能力有限，只是讲述了其中很浅层的一点数学内涵，希望诸位可以借此认识到概率的神奇之处，而我们现在可以正式进入我们的主题了，接下来我会主要结合自然语言处理的例子来对我的论点进行一层层的论述</p>
<p>首先，我们来思考这样一个问题，什么是语言，在人类的发展史上为什么会出现语言这么个东西（此次静静思考三十秒）</p>
<p>毋庸置疑的是语言是智人自几万年前认知革命以来智能不断进化的产物，而语言的诞生解决的最主要的问题就是人类之间的相互通信，哈哈，说到这里我们就可以开始从通信的角度去聊一聊语言这件事了，请读者现在想象一下你在和另外一个人交谈时的场景，别人说一句话，通过空气这一介质以340m/s的速度传到你的耳朵中，然后你理解了他想要表达的东西，而事实上这个模型十分简陋，首先，别人说话这件事代表着什么呢，而你理解别人这句话的意思又是怎样的一个过程呢，接下来我们开始细化一下这个模型</p>
<p>现在我们用一个更具体的例子，假设我们都活在一千年前的古代中国，那个时候我们还在用书信交流，而书信上写的也不是我们现在的白话文，而是文言文，比如说，你女票好久没有见过你了，很想念你，于是给你写了封信，飞鸽传书寄给你，信上写道：日日思君不见君，共饮长江水，你看到这句话，立刻明白了，你女票想你了，于是骑着一批快马，屁颠屁颠的就赶回去了，在这个过程中，我们可以用雅格布森的通信六要素去拟合这个模型，其中，你女票就是信源，她很思念你是她想表达的信息，而书信和飞鸽就是信道，来传输信息，而写在信上的那十二个字就是这一信息的另一种表达形式，在这里我们也可以看作是对原始的信息进行了一次编码，而你呢就是接受者，你读到了这封信，而且你很了解你女票的行文习惯，并根据上下文，读懂了你女票想表达的意思，而这一步也相当于是对信上的文字进行了一次解码，自此，我们可以看出这整个过程就完全是一个通信的模型嘛</p>
<p>认可这一模型对理解我接下来将要讲到的内容十分重要，所以希望读者在此耐心品味片刻，而我们现在继续来说语言这件事，赫拉利在《人类简史》中对语言有这样一段描述，他说呀：人类语言最独特的功能，并不在于能够传达关于人或野兽等实体存在事物的信息，而是能够传达关于一些根本不存在的信息，而这些我们通常将其称之为“虚构”的信息，而他之后就开始扯“虚构”这玩意对于人类文明发展是多么多么重要了，不过我们今天不会聊这些，但我们从中可以看出语言的一个特性，它包括很多“虚构”的成分，这一点也可以理解为信源本身主观的一些成分，也就是说不同人对同一个东西的理解可能是不一样的，这里回归到我们的通信模型，因为你和你女票相互了解，也可以说是对信息的编码和解码方式达成了共识，都知道正确的打开方式，所以信息理解起来不会有太多的障碍，可是如果跟其他人呢，比如说有一天，有一个暗恋你的妹子也给你写了一封信，上面有七个秀美的蝇头小字：山有木兮木有枝，你一看，一脸懵逼，不知道什么意思，可如果你看过前秦时的《越人歌》，就会知道这句诗是：山有木兮木有枝，心悦君兮君不知，妹子的意思清清楚楚呀</p>
<p>所以语言就是这么一个神奇的东西，它可以看作是一段在时间上连续的不确定函数（哈哈，看到这里是不是想到了恶心的随机信号分析与处理）而大多数情况下，一句话想表达的含义都跟上下文有关，而且在不同语境中还有极大的不确定性，而这些也增加了自然语言处理的难度，所以在大多数情况下我们只能说，语音识别是听话的人去努力猜测说话人想表达的意思，而不能百分百的确定，说到这里我们其实已经可以开始引入概率的内容了，不过在此之前，我还想先聊一聊信息熵这个东西</p>
<p>七十年前，伟大的香农同学在他的那篇本专业奠基之作《通信的数学原理》中提出了信息熵这么一个概念，（如果没有香农，我们每周是不是就可以少很多课了呢）他将信息理解为用来减少随机不确定性的东西，接下来举个有趣的例子</p>
<p>比如说呀，今年NBA季后赛，一共16支球队，最后究竟谁能赢得奥布莱恩杯呢，现在假设总决赛已经打完了，但很可惜你这几个月都在准备高考，没看（其实这个假设看上去很不合理）考完后，你问朋友哪个队拿了总冠军，朋友不直接告诉你，而是让你来猜，（此次停顿五秒钟，如果换作你你会怎么猜）于是你想到了数据结构里学的二分查找法，对16支队依次编号，比如骑士是1号，勇士2号，火箭3号……你首先问冠军在9到16号吗，朋友告诉你不在，于是你又问那在5-8号中吗，朋友告诉你还是不在，依次类推，只需要问四次就可以找到最后的总冠军球队，所以，四次之后果然不出你所料，4号湖人总冠军</p>
<p>而这里，香农同学用比特来作为信息度量的单位，以上的这些信息就值四个比特，而接下来给出信息熵的公式：<br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhJpQdD2JYhKZoRy6kkhYGVH.png?w=482&amp;h=51" alt="图片" loading="lazy"><br>
从公式中我们可以很明显的看出信息的大小是与概率有密切关系的，这一点很好理解，就比如说虽然进季后赛的球队一共有十六支，但每只球队的实力并不均等，就比如说火箭打爵士基本就是血虐，勇士和鹈鹕也是如此，所以他们夺冠的概率是不均等的，而我们上面对十六支球队进行无差别的排序，是在对这些球队一无所知的情况下，所以根据最大熵原理（也就是在你啥都不知道的时候，最好假设他们夺冠概率均等，没有差别）我们得到的信息熵是四比特，而如果提前知道每只球队的实力和夺冠概率，那么得到的结果就并非如此了</p>
<p>而我们现在还可以从两者定义的角度来看这两个概念，首先，概率的定义就是随机事件发生的可能性的度量，而信息则是减少随机不定性的东西，这两者生而就是有着千丝万缕的联系的，所以我们在研究自然语言处理这类信息时，也必然要引入概率的知识，好了，扯了这么多，我们终于可以来认真讲概率了</p>
<p>首先一个随机事件A发生的概率为P（A），随机事件B发生的概率为P（B），而接下来我们又定义：在事件B发生的条件下A发生的概率为P（A|B），如果A和B之间毛关系没有，那么P（A|B）还是等于P（A），同时我们还有一个公式P（A|B）=P（AB）/P（A），以上就是我们一般会在概率论基础第一章学到的条件概率（貌似高中就学过）应该没学过高数的同学都能看懂吧，而接下来给出一个牛逼哄哄的公式：P（A|B）=P（A）<em>P（B|A）/P（B）而这就是传说中的贝叶斯公式的最简化版本（因为不想再引入全概率公式，所以先凑活用）现在我们来仔细分析一下这个式子，P（A）是事件A发生的概率，P（A|B）是在事件B发生的条件下A发生的概率，这里我们还可以将P（A）称为“先验概率”，也就是在事件B发生之前我们对A事件作出的一个判断，而P（A|B）则称为后验概率，而P（B|A）/P（B）这一项我们这将其称之为“调整因子”，他会在B事件发生后对A事件发生的概率进行重新评估，因此我们上面对公式也可以写做：后验概率=先验概率</em>调整因子，而贝叶斯公式在我们后面的推导中将起到很关键的作用</p>
<p>好了，说完贝叶斯公式我们来继续聊语言这件事，我们之前用通信的模型对两个人之间用语言交流这件事进行过剖析，我们现在可以再来回忆一下，如果你妹子脑子里想的是一句话，我们现在用s1s2s3s4s5……sn来表示，这是她想表达的意思，而写在纸上，则变成了o1o2o3o4……on，要注意这两者是不一样的，就比如说明明是“我想你”却非得整一句文绉绉的“日日思君不见君”，而现在我们假设你已经推测出了你女票的意思（此处先将o1o2o3o4……on放到一边去）可是你并不确定你得到的m1m2m3m4……mn是否就是你女票原本想表达的意思，而这本身就是一个猜测的过程，其实你女票想表达的原始信息s1s2s3s4s5……sn在发生后，已经是一个确定的值，可是你是永远无法得到一个确定的值的，你只能进行猜测，而接下来问题就来了，我们究竟是基于什么来进行猜测的呢</p>
<p>比如说我现在说一句话：湖人总冠军，这句话在句法上是没有问题的，如果我们把这句话中的某些词换一换位置呢，比如：总冠军湖人，其实还是没有问题，可如果改成：湖中人军冠，就有问题了，因为我们一般在根据上下文的语境的情况下，会判断“湖”后面跟“人”的可能性更大，而“总冠军”也会比“军冠总”的概率大，而在此我们就要引入我们自然语言处理的一个核心思路，也就是贾里尼克提出的统计语言模型：一个句子是否合理，其实就是看它的可能性的大小（多么精炼的一句总结呀）这里我们再把上面的这个序列s1s2s3s4s5……sn拿出来分析一下，这个序列出现的概率是多少呢，想想我们之前提到的条件概率，可得以下等式：（因为笔者的图是直接截取的，下图中的w等价于s） <br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhLpUA7wM9dLUoRwris7WL0L.png?w=482&amp;h=70" alt="图片" loading="lazy"><br>
这个式子我们也很好理解，比如Sn+1往往和Sn,Sn-1……有关，就像我们在理解一个句子中的词时，往往要结合上下文来分析，但是这样又出现了一个问题，随着序列长度的不断增加，Sn将和前面的n-1项都相关，这就会使得这条尾巴越来越长，非常不利于我们求解计算，因此在这个时候我们就要抛出此文的又一大核心知识——马尔可夫过程，机智的马尔可夫同学估计是嫌上面这个模型太过复杂，因此他假设：在随机过程的每一步的结果最多只与上一步有关，而与其他无关，即Sn+1只和Sn有关，Sn只和Sn-1有关，于是乎上面的这个条件概率就可以简化为：<br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhKxgEzmCepMeavd3PRrMXUW.png?w=482&amp;h=73" alt="图片" loading="lazy"><br>
而在这种情况下，我们可以将s1s2s3s4s5……sn这一序列看成是一条马尔可夫链，打一个很形象的比喻，它就像一条长长的列车，前一节车厢拖着后一节车厢，在铁轨上屁颠屁颠的前行，虽然我们说后一项的概率只有前一项来决定，可是前一项的概率又由前一项的前一项决定，所以它们之间还是有连带关系的，就像你去分析或者某两节车厢之间的受力的情况，还是得去研究它之前的n节车厢，当然，光有马尔可夫链是不行的，我们接下里还要引入隐含马尔可夫模型来进一步分析</p>
<p>回到我们之前说的，写在纸上的信息其实并不是s1s2s3s4s5……sn，而是o1o2o3o4……on，也就是说你真正看到的是那句“日日思君不见君”，你要通过这个o1o2o3o4……on序列（可见的）来推断出原本的s1s2s3s4s5……sn，而其中推断的意思我们之前说过：判断一个句子是否合理，其实就是看它的可能性的大小，推断也就是要找到在已知o1o2o3o4……on的情况下让s1s2s3s4s5……sn发生的概率最大的那个序列 <br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhKNXuNHT21K4Zlfrk-IZ1cm.png?w=482&amp;h=73" alt="图片" loading="lazy"><br>
我们现在再来假设每一个O对应一个S，即O1-S1，O2-S2……则隐含马尔可夫模型如下图所示： <br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhJBcjV6K1tKFZrk64iXUbA5.webp?w=474&amp;h=184" alt="图片" loading="lazy"><br>
说到这里诸位可能还是很难去理解隐含马尔可夫模型，我们接下来还是用一个更加具体的例子来解释一下（特在此声明，此方法来自于知乎某高票回答，并非笔者原创）现在假设在你面前有三个骰子，一个四面的，点数为1，2，3，4，掷到每一点概率为1/4，一个为六面的，点数为1，2，3，4，5，6，掷到每一点概率为1/6，还有一个为八面的，点数为1，2，3，4，5，6，7，8，掷到每一点概率为1/8，现在我只告诉你骰子筛出的点数结果，而不告诉你是哪一个骰子筛的，比如说告诉你筛了一个4出来，那么这个4可能是四面骰筛出来的，也可能是六面骰筛出来的，还可能是八面骰筛出来的，而如果我们之前定义使用三个骰子的概率均等，那么掷出4这一结果，三个骰子的概率分别为：P（四面骰）=1/3 *1/4，P（六面骰）=1/3 *1/6，P（八面骰）=1/3 *1/8，而如果告诉你得到的序列为4—6，那么计算它们的概率就会复杂很多，因为6可能是六面骰掷出来的，也可能是八面骰掷出来的，而我们一般来说都会去找得到这一序列可能性最大的一种情况，比如说第一次的4最可能是四面骰掷出来的，而第二次的6最可能是六面骰掷出来的，而这对应的实际的情况就是四面骰掷出4，然后六面骰掷出6，其概率为1/3 *1/4 *1/3 *1/6</p>
<p>举这个投骰子的模型是希望诸位更好的理解“隐含”这两个字的含义，在实际的自然语言处理中，也是如此，我们看到的序列o1o2o3o4……on只是现式的，而我们需要做的就是猜测它所隐含的内容，而其中运用的最多的工具就是概率的知识，在此处再插叙一段自己关于隐含马尔可夫模型的感概（与后面论证无关）在写这篇作业时，突然想到了乔老爷子在斯坦福那篇传世的十五分钟演讲，因为笔者是铁杆果粉，对这篇演讲记忆犹新，记得在其中有这么一段话：（因为不想改变乔帮主原意，故直接放上英文原稿）</p>
<p>Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.</p>
<p>每个人的一生都是一条隐含马尔可夫链，在我们平常的生活中，往往看不到一些事物对你未来人生的改变，而即便是那些你看到的，你听到的，也许也并非它的本来模样，可是当我们再蓦然回首时，才发现生命是由一个个点组成的，那些你做过的努力，付出的汗水，踩过的坑，都是有意义的，它们就像多米诺骨牌一样，一点一滴的在影响着你的生命，所以，坚信你所相信的东西，相信这些过程会让你的生命与众不同（我希望能认真看到这里的读者，也能认同我所说的这些话的）</p>
<p>现在回到我们的分析，关于以上的推导，我们用之前提到的贝叶斯公式进行一次变换， 得到以下式子： <br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhLyI06uFwhOpJ6laOJvF21S.webp?w=482&amp;h=90" alt="图片" loading="lazy"><br>
现在我们逐一来分析这个式子中的几个概率，首先看P（o1o2o3o4……on），对于o1o2o3o4……on这个序列，本来指的是信源在发送端产生信息的可能性，但是这个序列我们现在已经知道了，它是我们看得见的，所以这里再来研究其概率意义不大，所以其主要功能是在分母起归一化的作用，而后两项则是我们要着重研究的，首先，P（o1o2o3o4……on|s1s2s3s4s5……sn）是指信源在发射端由序列s1s2s3s4s5……sn产生我们接受到的信息序列o1o2o3o4……on的概率，这里你也可以理解为你妹子很想你，写下了“日日思君不见君”，但她为什么不写“玲珑骰子安红豆，入骨相思知不知”呢，也就是说这件事并不是一定发生的，也是有一定概率的，而P（s1s2s3s4s5……sn）我们之前也分析过，将它用条件概率公式展开，就是看这句话可能性的大小，用贾里尼克的话来说就是合理不合理，而我们现在要求的就是这两个概率乘积的最大值（如果问我为什么是最大值，我觉得你读到这里就可以不用再继续了）</p>
<p>而想要求解以上最大值的问题我们就不得不引入两大数学方法，鲍姆-韦尔奇算法（或者称EM算法）以及维特比算法，接下来我们一点点的来讲（由于此处开始对数学水平有一定的要求，为遵循我在开篇说到的原则，两个算法我都会点到为至，不做深究）</p>
<p>在我们上面的分析中有的读者可能会很困惑，就是P（St|St-1)，P（Ot|St）是怎么知道的呢，大多数人的第一想法应该都是用频率去估计概率，比如说，如果我们有足够多的人工标记的数据，就可以知道经过状态St有多少次，记为M（St），而每次经过这一状态时分别产生的输出Ot是什么，其次数则记为M（Ot），因此，用两者的比值就可以近似估计出P（Ot|St），而P（St|St-1)同理，可事实上这种有监督的训练方法，数据都是要人工去标注的，我们先不谈人力成本的问题，对于语音这种随时间变化的问题，我们很难人工去确定产生某个语言的状态序列，而数据的标注就变得不切实际，所以就需要找到另外的方法，也就是EM算法</p>
<p>在此，我们先来讲个简单一点的算法，极大似然法，理解其中的思想将很有帮助，接下来我们先讲一下高斯同学的一个小故事，话说呀，当时的天文学家总喜欢拿着望远镜去研究天上的星星，把它们的位置和轨迹记录下来，而有一波天文学家就在研究这个谷神星（话说名字我记不太清楚了，错了请指正）而有一天可能是哪个马大哈看着看着就睡着了，于是星星跟丢了，结果马大哈醒来一看，吓了一尿，这可不行呀，不然之前的研究成果不久都白费了吗，所以这些天文学家就向全世界的数学家征集方法，来找到这颗破星星，当然他们会提供以前记录的一些坐标和轨迹，可是，当时很多的著名的数学家都没能找到一个很好的数学模型去拟合这些个点，他们建模的思路通常都是用插值的方法，让自己的曲线经过尽可能多的点，而事实是这样得到的模型效果并不好，其实我们之前特别火的神经网络在训练时也经常会出现类似的问题，我们将其称作“过拟合”，这样这个模型在训练集中的表现可能十分优异，可是到了测试集，却往往会出现各种各样的问题，因为根据我们实际的研究经验可以知道：一个优秀的数学模型在形式上应该是简单的，而我们伟大的高斯同学就一眼看出了这个关键所在（那时还只有17岁）他认为这些点应该是以某种规律分布在某条直线的两侧点，而我们要做的事情就是找到这条直线，然后就能找到谷神星，而接下来就有了我们伟大的最小二乘法</p>
<p>现在我们假设有这样一条直线y=ax+b(假设在二维平面内）在它周围分布着很多的点，a,b两个参数未知，我们现在的目的是确定a,b使得所有点到这条直线的长度平方和最小，这里虽然我们通过求导是可以直接将a.b算出来的，也就是最小二乘法的公式，但我们今天不用这样的方法，我们来想一下，如果我们现在先假设a=0,b=0,那么这些点的平方和应该会很大（在机器学习中我们通常将这些平方和称作损失函数）而我们现在可以逐渐调整a,b的值，来使得损失函数变小，直至最后收敛到一个有限值，而我们具体要怎样来调整a,b的值呢，有很多方法，比如大多数机器学习初学者都会用到的梯度下降法，但这种方法的弊端是有可能你找到的最优质仅仅是局部最优而非全局最优，所以你还可以采用SDG，AdaDelta这些下降算法来逐步调整参数，此处不在继续展开</p>
<p>而对于以上找直线这个问题我们还可以换一个角度去思考，我们假设这些点到这条直线的长度满足正态分布（记住，这一点很重要），那么我们设这个差值m=Yi-(aXi+b)满足均值为0方差为“布拉布拉”（原谅我不会打）的正态分布，而（a,b)可以看作一个行向量，那么就可以得到一下等式<br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhKmxTziqFZOVa8idwc23eV9.webp?w=482&amp;h=139" alt="图片" loading="lazy"><br>
在上诉公式中，我们先求对于每一个Xi在此正太分布和（a,b) 的情况下的概率，然后将他们累乘（由于各个点之间没有什么联系，也就是相互独立的）也就得到了所有点在此模型下的概率，正如我们之前在分析一句话的合理性时，用到的是找到是这句话概率最大的那个序列，这里我们要找的是使这个概率之积最大的（a,b)，但对于这一乘积我们并不好直接对此进行分析，要通过一部转换，也就是对其取对数，这样所有的累乘就变成了累加，而对数函数本身是一个凸函数，也避免了给我们之后的分析带来不必要的麻烦<br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhKk3Y9LwNxIIY4OojJWwoDe.webp?w=482&amp;h=160" alt="图片" loading="lazy"><br>
通过进一步推导我们发现问题还是转换为求这些点到直线平方和的最小值的问题上了，当然这只是针对这一问题出现的，对于其他问题不一定也满足，而到此，我们刚刚所讲的这一方法就是经典的极大似然法，它的整个流程我们可以理解为一个反向推理的过程，通常我们会根据已知的条件做一步假设，比如上面先设定的高斯分布模型，然后再求概率的乘积，并找到使乘积达到极大值时参数应该满足的条件，而这些步骤如果简化为两个过程就是：E和M，E就是Expectation，我们先猜想模型中的一些参数，然后再Maximization，将可观测到的数据和我们之前猜测的数据结合起来极大化对数似然，最终得到我们想要的参数，而通常来说这个过程并不是一步到位的，它需要反复的迭代，不过基于其中更加复杂的数学证明（此处省略，其实笔者也没深究过）这个算法是收敛的，而吴军博士在它的《数学之美》中也将EM算法称之为“上帝的算法”，你可以想象一下，在这整个过程中，我们除了要设定一个初始值（其实大多数情况下初始值可以随便选取）而接下来的事情就完全交给机器去做了，它会在不需要人工干预的情况下去按你提前设计的方式来修改模型的参数，并最终达到我们想要的结果，这种不需要任何先验经验的EM算法在我们现在的机器学习中也可以说是十分核心的数学思想了</p>
<p>而回到我们的统计语言模型，其中的P（St|St-1)，P（Ot|St）都可以看作这个模型的参数，运用EM算法，E过程就是根据现有的模型参数来计算每个状态之间转移的次数和每个状态产生它们输出的次数，而M过程就是根据这些次数重新估计隐含马尔可夫模型的参数，至此，我们已经讲完了EM算法在自然语言处理中的应用（建议读者此时平心静气冥想半分钟，仔细品味一下EM算法的神奇一处）<br>
根据我们前面所做的工作，假设我们现在已经知道了P（St|St-1)，P（Ot|St）的值，但即便如此，我们还是要回到求以下式子的最大值的问题上来<br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhLWvyOhmNxGi6ePektZv3Sh.webp?w=482&amp;h=141" alt="图片" loading="lazy"><br>
接下来我们看下面的这张图 <br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhL0Rk-eGx9EVK3ioPIguHhe.webp?w=499&amp;h=359" alt="图片" loading="lazy"><br>
在我们之前讲到的极大似然法中，我们分析过对累乘运算进行处理的复杂性，所以我们可以取对数后将其转换为累加运算，并求这个累加和的最大值， 以求P（s1s2s3s4s5……sn）的最大值为例，我们现在将这个序列逐个对应到上图中来，S1对应X11，而根据马尔可夫模型，S2可能多种可能，而其概率与其前一项有关，也就是和S1相关联，我们将可能的S2对应于上图的X21，X21，X23……X2n，而由X11转移到X21，X21，X21这些节点的概率不等，我们之前通过EM算法已经求出这些转移概率，并依次类推，S3也有多种可能，而这样X21，X22，X23……X2n到X31，X31，X33……X3m就有n<em>m种可能的组合，也就对应着n</em>m种不同的概率，而现在我们的目的就是要找到这样一条路径，使得到最后的Sn时，在这条路径上经过的概率之和最小，简单来说就是一个求最短路径的问题（哈哈，看到这里，读者们是不是感觉前面扯了这么多，终于快要出结果了呢）可是你想一下，我们要怎么去找到这个最短路径呢，通常来说我们可以枚举出所有的路径，并求其长度（也就是概率之和），这种方法是一定可以找到最小值的，可是这么做存在一个很致命的问题，现在我们假设以上模型的每一层的节点数都为N，一共有M层，那么粗略算一下，就有N的M次幂种可能的路径，毫无疑问在实际处理中这个值将会异常庞大，大到计算机也很难对其进行运算，因此，这一方法在理论上可行，但实际上却很难实现，所以我们就要引入之前提到的维特比算法，或者说是动态规划的方法，现在假设我们已经知道了从第一层到第n-1层的N个节点的所有路径及其长度，其中一共有N的n-1次幂种可能，如果我们再加上第n层，并直接相乘，结果就会变成N的n次幂种可能，但如果我们仔细思考一下就会发现，由于我们要找的是最短路径，对于从第一个节点到第n层某一节点Xnj的最短路径，必然包含从第一个节点到第n-1层所有节点到最短路径其中的一条，单一第一层和二层来说，就是一下的公式：<br>
<img src="https://docimg10.docs.qq.com/image/AgAABZ6LPhJCrV0F7tdAw67bPf21Kpj7.png?w=482&amp;h=75" alt="图片" loading="lazy"><br>
而现在我们假设已经知道了从初识节点到第n-1层所有节点到最短路径，则只需要在进行最多N<em>N次运算就可以得到从初识节点到第n层所有节点到最短路径，依次类推，通过在前一层的最短路径的基础上来计算后一层的最短路径，那么总的复杂度将减小到M</em>N*N，即使M和N都很大，但计算机依然能够在有效的时间内对其进行运算，至此我们已经讲完了维特比算法，也就是说我们可以将计算整个序列概率的最大值这个问题实现了<br>
忽忽悠悠写到这里字数已经快破万了，有点累了，不过自然语言处理这块也算是终于讲完了，来稍微回顾一下我们提到的一些关键点，从最开始的通信模型，到之后介绍的贝叶斯推断，以及最核心的隐含马尔可夫模型，还有最后的两大算法：EM算法和维特比算法，可以说期间几乎每一个步骤都有概率的渗透，在对概率论有一定的认识后，才能够深入理解和熟练掌握这些模型以及数学方法，而笔者写这篇文章的初衷也就是希望能让更多的人意识到数学的美丽之处，而由于笔者本身所学专业的原因，对概率论这门课也是情有独钟，而它对于笔者之后专业课的学习也至关重要，所以笔者希望看完此文的读者，尤其是和我一样的学生，能真正重视概率论这门课，而不是仅仅停留在考试上，如果单纯应付考试，对于一般大学非数学专业的学生而言，也许只需要考前两天翻一翻书就能拿到一个还看得过去的分数，但这并不是学习的目的，愿这一点诸位能够认同</p>
<p>而对于以上讲述的通过自然语言处理的例子以及其中的图片，基本来自于吴军博士的《数学之美》，虽然可能有读者会说在深度学习一统江湖的年代，我们现在通常会选择循环神经网络也就是RNN的模型去做类似的问题，包括其中也有很多的变式，比如加入了信息阀门的LSTM网络，其得到的结果肯定会比基于隐马的统计语言模型更好，但笔者该文仅想通过这一例子近可能多的渗透一些概率的知识，所以希望对此有疑问的读者可以理解</p>
<p>而至此，笔者也有些累了，虽然在我原本的构思中是想再讲一个卡尔曼滤波算法的，笔者这学期用Arduino做了一台四轴飞控，当时研究无人机核心控制部分的卡尔曼滤波算法时还没有学习概率论，所以本来想分享一下自己踩过的一些坑，但由于之前自然语言处理的例子扯的太多了，所以现在也无心再写下去了，不过最后还是要感谢能坚持看完的读者，由于笔者是工科生，文笔真的很烂，文中也难免有很多疏漏，希望耐心的读者和各位大佬可以帮忙指出，笔者都会虚心接受</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://deshuin.github.io/post/bi-er-ge-luo-si-ji-hui-you-li-yu-du-tu-shi-zui-jia-de-du-fa-jiu-shi-da-du/">
              <h3 class="post-title">
                比尔·格罗斯：机会有利于赌徒时，最佳的赌法就是大赌
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'a1de8a60a390c2389d0b',
    clientSecret: 'cbc5b8355c26e5b41fab04cb846a11ea02b2b0d7',
    repo: 'deshuin.github.io',
    owner: 'deshuin',
    admin: ['deshuin'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://deshuin.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
